# Copyright 2025 The game_arena Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for tournament utilities."""

import io

import chess
import pyspiel
from absl.testing import absltest

from game_arena.harness import tournament_util


class TournamentUtilTest(absltest.TestCase):

    def test_convert_to_readable_state_poker_player_0(self):
        serialized_state = """# Automatically generated by OpenSpiel SerializeGameAndState
[Meta]
Version: 1

[Game]
universal_poker(betting=nolimit,bettingAbstraction=fullgame,blind=50 100,firstPlayer=2 1 1 1,numBoardCards=0 3 1 1,numHoleCards=2,numPlayers=2,numRanks=13,numRounds=4,numSuits=4,stack=20000 20000)
[State]
3
39
15
10
1
1
31
34
19
200
1
47
1
1
21
"""
        _, state = pyspiel.deserialize_game_and_state(serialized_state)
        state_str = state.to_string()
        readable_state = tournament_util.convert_to_readable_state(
            game_short_name="universal_poker", state_str=state_str, current_player=0
        )
        self.assertEqual(
            readable_state,
            """BettingAbstraction: FULLGAME
P0 Cards: Js2s
BoardCards KsTh9s7d6s
Node type?: Player node for player 0
]
Round: 3
Spent: [P0: 200  P1: 200  ]

Action Sequence: ddddccdddpcdccd""",
        )

    def test_convert_to_readable_state_poker_player_1(self):
        serialized_state = """# Automatically generated by OpenSpiel SerializeGameAndState
[Meta]
Version: 1

[Game]
universal_poker(betting=nolimit,bettingAbstraction=fullgame,blind=50 100,firstPlayer=2 1 1 1,numBoardCards=0 3 1 1,numHoleCards=2,numPlayers=2,numRanks=13,numRounds=4,numSuits=4,stack=20000 20000)
[State]
3
39
15
10
1
1
31
34
19
200
1
47
1
1
21
1
"""
        _, state = pyspiel.deserialize_game_and_state(serialized_state)
        state_str = state.to_string()
        readable_state = tournament_util.convert_to_readable_state(
            game_short_name="universal_poker", state_str=state_str, current_player=1
        )
        self.assertEqual(
            readable_state,
            """BettingAbstraction: FULLGAME
P1 Cards: 5s4h
BoardCards KsTh9s7d6s
Node type?: Player node for player 1
]
Round: 3
Spent: [P0: 200  P1: 200  ]

Action Sequence: ddddccdddpcdccdc""",
        )


class TestFormatChessMovetext(absltest.TestCase):

    def setUp(self):
        super().setUp()
        self.game = chess.pgn.Game()
        self.game.add_line(
            [
                chess.Move.from_uci("g1f3"),
                chess.Move.from_uci("d7d5"),
                chess.Move.from_uci("c2c4"),
            ]
        )

    def test_format_chess_movetext_default(self):
        self.assertEqual(
            tournament_util.format_chess_movetext(
                self.game,
                numbering_scheme="default",
                use_lan=False,
                add_current_fen=False,
            ),
            "1. Nf3 d5 2. c4",
        )

    def test_format_chess_movetext_lan(self):
        self.assertEqual(
            tournament_util.format_chess_movetext(
                self.game,
                numbering_scheme="default",
                use_lan=True,
                add_current_fen=False,
            ),
            "1. g1f3 d7d5 2. c2c4",
        )

    def test_format_chess_movetext_all_numbering(self):
        self.assertEqual(
            tournament_util.format_chess_movetext(
                self.game,
                numbering_scheme="all",
                use_lan=False,
                add_current_fen=False,
            ),
            "1. Nf3 1... d5 2. c4 2...",
        )

    def test_format_chess_movetext_no_numbering(self):
        self.assertEqual(
            tournament_util.format_chess_movetext(
                self.game,
                numbering_scheme="none",
                use_lan=False,
                add_current_fen=False,
            ),
            "Nf3 d5 c4",
        )

    def test_format_chess_movetext_with_fen(self):
        self.assertEqual(
            tournament_util.format_chess_movetext(
                self.game,
                numbering_scheme="default",
                use_lan=False,
                add_current_fen=True,
            ),
            "1. Nf3 d5 2. c4 { [%FEN"
            " rnbqkbnr/ppp1pppp/8/3p4/2P5/5N2/PP1PPPPP/RNBQKB1R b KQkq" + " - 0 2] }",
        )


class TestGetPgn(absltest.TestCase):

    def test_get_pgn_with_moves(self):
        game = pyspiel.load_game("chess")
        state = game.new_initial_state()
        state.apply_action(state.string_to_action("e4"))
        state.apply_action(state.string_to_action("e5"))
        pgn = tournament_util.get_pgn(state)
        self.assertEqual(pgn.headers["White"], "White")
        self.assertEqual(pgn.headers["Black"], "Black")
        self.assertEqual(pgn.headers["Result"], "*")
        self.assertEqual(str(pgn.mainline_moves()), "1. e4 e5")

    def test_get_pgn_with_custom_player_names(self):
        game = pyspiel.load_game("chess")
        state = game.new_initial_state()
        pgn = tournament_util.get_pgn(state, player_names=["Player A", "Player B"])
        self.assertEqual(pgn.headers["White"], "Player B")
        self.assertEqual(pgn.headers["Black"], "Player A")

    def test_get_pgn_terminal_state(self):
        spiel_game = pyspiel.load_game("chess")
        spiel_state = spiel_game.new_initial_state()
        # Fool's Mate (https://www.chess.com/terms/fools-mate):
        pgn = """[Event "60th US Open"]
[Site "Omaha, NE USA"]
[Date "1959.08.01"]
[Round "12"]
[White "Walter Thomas Mayfield"]
[Black "William Robert Trinks"]
[Result "1-0"]
[EventDate "?"]
[ECO "B00"]
[WhiteElo "?"]
[BlackElo "?"]
[PlyCount "5"]
[Link "https://www.chess.com/analysis"]

1. e4 g5 2. Nc3 f5 3. Qh5# 1-0"""
        pychess_game = chess.pgn.read_game(io.StringIO(pgn))
        pychess_board = chess.Board()
        for move in pychess_game.mainline_moves():
            spiel_state.apply_action(
                spiel_state.string_to_action(pychess_board.san_and_push(move))
            )
        print(f"{spiel_state=}")
        print(f"{spiel_state.is_terminal()}")
        pgn_from_state = tournament_util.get_pgn(spiel_state)
        self.assertEqual(pgn_from_state.headers["Result"], "1-0")


class TestGetActionStringHistory(absltest.TestCase):

    def test_get_action_string_history_chess_initial_state(self):
        game = pyspiel.load_game("chess")
        state = game.new_initial_state()
        self.assertEqual(tournament_util.get_action_string_history(state), "1.")

    def test_get_action_string_history_chess_with_moves(self):
        game = pyspiel.load_game("chess")
        state = game.new_initial_state()
        state.apply_action(state.string_to_action("e4"))
        state.apply_action(state.string_to_action("e5"))
        self.assertEqual(
            tournament_util.get_action_string_history(state), "1. e4 e5 2."
        )


class TestGetChessPiecePositions(absltest.TestCase):

    def test_sicilian_defense_position(self):
        """Tests chess piece positions for a common opening position."""
        fen = "r1bqkbnr/pp1ppppp/2n5/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3"
        expected = {
            "a1": "white rook",
            "b1": "white knight",
            "c1": "white bishop",
            "d1": "white queen",
            "e1": "white king",
            "f1": "white bishop",
            "h1": "white rook",
            "a2": "white pawn",
            "b2": "white pawn",
            "c2": "white pawn",
            "d2": "white pawn",
            "f2": "white pawn",
            "g2": "white pawn",
            "h2": "white pawn",
            "f3": "white knight",
            "e4": "white pawn",
            "c5": "black pawn",
            "c6": "black knight",
            "a7": "black pawn",
            "b7": "black pawn",
            "d7": "black pawn",
            "e7": "black pawn",
            "f7": "black pawn",
            "g7": "black pawn",
            "h7": "black pawn",
            "a8": "black rook",
            "c8": "black bishop",
            "d8": "black queen",
            "e8": "black king",
            "f8": "black bishop",
            "g8": "black knight",
            "h8": "black rook",
        }
        result = tournament_util.get_chess_piece_positions(fen)
        self.assertDictEqual(result, expected)

    def test_empty_squares(self):
        """Test the inclusion of empty squares, Kasparov vs. Topalov 1999."""
        fen = "8/Q6p/6p1/5p2/5P2/2p3P1/3r3P/2K1k3 b - - 3 44"
        expected = {
            "a1": "empty",
            "b1": "empty",
            "c1": "white king",
            "d1": "empty",
            "e1": "black king",
            "f1": "empty",
            "g1": "empty",
            "h1": "empty",
            "a2": "empty",
            "b2": "empty",
            "c2": "empty",
            "d2": "black rook",
            "e2": "empty",
            "f2": "empty",
            "g2": "empty",
            "h2": "white pawn",
            "a3": "empty",
            "b3": "empty",
            "c3": "black pawn",
            "d3": "empty",
            "e3": "empty",
            "f3": "empty",
            "g3": "white pawn",
            "h3": "empty",
            "a4": "empty",
            "b4": "empty",
            "c4": "empty",
            "d4": "empty",
            "e4": "empty",
            "f4": "white pawn",
            "g4": "empty",
            "h4": "empty",
            "a5": "empty",
            "b5": "empty",
            "c5": "empty",
            "d5": "empty",
            "e5": "empty",
            "f5": "black pawn",
            "g5": "empty",
            "h5": "empty",
            "a6": "empty",
            "b6": "empty",
            "c6": "empty",
            "d6": "empty",
            "e6": "empty",
            "f6": "empty",
            "g6": "black pawn",
            "h6": "empty",
            "a7": "white queen",
            "b7": "empty",
            "c7": "empty",
            "d7": "empty",
            "e7": "empty",
            "f7": "empty",
            "g7": "empty",
            "h7": "black pawn",
            "a8": "empty",
            "b8": "empty",
            "c8": "empty",
            "d8": "empty",
            "e8": "empty",
            "f8": "empty",
            "g8": "empty",
            "h8": "empty",
        }
        result = tournament_util.get_chess_piece_positions(
            fen, include_empty_squares=True
        )
        self.assertDictEqual(result, expected)

    def test_empty_board(self):
        """Tests an empty board."""
        fen = "8/8/8/8/8/8/8/8 w - - 0 1"
        expected = {}
        self.assertDictEqual(tournament_util.get_chess_piece_positions(fen), expected)


class TestGetChessAsciiBoard(absltest.TestCase):

    def test_get_ascii_board_chess(self):
        """Tests ASCII board generation from PySpiel state."""
        pyspiel_game = pyspiel.load_game("chess")
        pyspiel_state = pyspiel_game.new_initial_state(
            "r1bqkb1r/pppp1Qpp/2n2n2/4p3/2B1P3/8/PPPP1PPP/RNB1K1NR b KQkq - 0 4"
        )
        expected_ascii = (
            """r . b q k b . r 8
p p p p . Q p p 7
. . n . . n . . 6
. . . . p . . . 5
. . B . P . . . 4
. . . . . . . . 3
P P P P . P P P 2
R N B . K . N R 1
a b c d e f g h"""
            + "  \n"
            + "Uppercase letters represent white pieces and lowercase letters"
            " represent black pieces. The numbers in the right-most column denote"
            " the ranks and the letters in the bottom row denote the files."
        )
        self.assertEqual(
            tournament_util.get_ascii_board("chess", pyspiel_state),
            expected_ascii,
        )


if __name__ == "__main__":
    absltest.main()
