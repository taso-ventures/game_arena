# Copyright 2025 The game_arena Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for tournament utilities."""

import io
import chess
from game_arena.harness import tournament_util
from absl.testing import absltest
import pyspiel


class TournamentUtilTest(absltest.TestCase):

  def test_convert_to_readable_state_poker_player_0(self):
    serialized_state = """# Automatically generated by OpenSpiel SerializeGameAndState
[Meta]
Version: 1

[Game]
universal_poker(betting=nolimit,bettingAbstraction=fullgame,blind=50 100,firstPlayer=2 1 1 1,numBoardCards=0 3 1 1,numHoleCards=2,numPlayers=2,numRanks=13,numRounds=4,numSuits=4,stack=20000 20000)
[State]
3
39
15
10
1
1
31
34
19
200
1
47
1
1
21
"""
    _, state = pyspiel.deserialize_game_and_state(serialized_state)
    state_str = state.to_string()
    readable_state = tournament_util.convert_to_readable_state(
        game_short_name='universal_poker', state_str=state_str, current_player=0
    )
    self.assertEqual(
        readable_state,
        """BettingAbstraction: FULLGAME
P0 Cards: Js2s
BoardCards KsTh9s7d6s
Node type?: Player node for player 0
]
Round: 3
Spent: [P0: 200  P1: 200  ]

Action Sequence: ddddccdddpcdccd""",
    )

  def test_convert_to_readable_state_poker_player_1(self):
    serialized_state = """# Automatically generated by OpenSpiel SerializeGameAndState
[Meta]
Version: 1

[Game]
universal_poker(betting=nolimit,bettingAbstraction=fullgame,blind=50 100,firstPlayer=2 1 1 1,numBoardCards=0 3 1 1,numHoleCards=2,numPlayers=2,numRanks=13,numRounds=4,numSuits=4,stack=20000 20000)
[State]
3
39
15
10
1
1
31
34
19
200
1
47
1
1
21
1
"""
    _, state = pyspiel.deserialize_game_and_state(serialized_state)
    state_str = state.to_string()
    readable_state = tournament_util.convert_to_readable_state(
        game_short_name='universal_poker', state_str=state_str, current_player=1
    )
    self.assertEqual(
        readable_state,
        """BettingAbstraction: FULLGAME
P1 Cards: 5s4h
BoardCards KsTh9s7d6s
Node type?: Player node for player 1
]
Round: 3
Spent: [P0: 200  P1: 200  ]

Action Sequence: ddddccdddpcdccdc""",
    )


class TestFormatChessMovetext(absltest.TestCase):

  def setUp(self):
    super().setUp()
    self.game = chess.pgn.Game()
    self.game.add_line([
        chess.Move.from_uci('g1f3'),
        chess.Move.from_uci('d7d5'),
        chess.Move.from_uci('c2c4'),
    ])

  def test_format_chess_movetext_default(self):
    self.assertEqual(
        tournament_util.format_chess_movetext(
            self.game,
            numbering_scheme='default',
            use_lan=False,
            add_current_fen=False,
        ),
        '1. Nf3 d5 2. c4',
    )

  def test_format_chess_movetext_lan(self):
    self.assertEqual(
        tournament_util.format_chess_movetext(
            self.game,
            numbering_scheme='default',
            use_lan=True,
            add_current_fen=False,
        ),
        '1. g1f3 d7d5 2. c2c4',
    )

  def test_format_chess_movetext_all_numbering(self):
    self.assertEqual(
        tournament_util.format_chess_movetext(
            self.game,
            numbering_scheme='all',
            use_lan=False,
            add_current_fen=False,
        ),
        '1. Nf3 1... d5 2. c4 2...',
    )

  def test_format_chess_movetext_no_numbering(self):
    self.assertEqual(
        tournament_util.format_chess_movetext(
            self.game,
            numbering_scheme='none',
            use_lan=False,
            add_current_fen=False,
        ),
        'Nf3 d5 c4',
    )

  def test_format_chess_movetext_with_fen(self):
    self.assertEqual(
        tournament_util.format_chess_movetext(
            self.game,
            numbering_scheme='default',
            use_lan=False,
            add_current_fen=True,
        ),
        '1. Nf3 d5 2. c4 { [%FEN'
        ' rnbqkbnr/ppp1pppp/8/3p4/2P5/5N2/PP1PPPPP/RNBQKB1R b KQkq'
        + ' - 0 2] }',
    )


class TestGetPgn(absltest.TestCase):

  def test_get_pgn_with_moves(self):
    game = pyspiel.load_game('chess')
    state = game.new_initial_state()
    state.apply_action(state.string_to_action('e4'))
    state.apply_action(state.string_to_action('e5'))
    pgn = tournament_util.get_pgn(state)
    self.assertEqual(pgn.headers['White'], 'White')
    self.assertEqual(pgn.headers['Black'], 'Black')
    self.assertEqual(pgn.headers['Result'], '*')
    self.assertEqual(str(pgn.mainline_moves()), '1. e4 e5')

  def test_get_pgn_with_custom_player_names(self):
    game = pyspiel.load_game('chess')
    state = game.new_initial_state()
    pgn = tournament_util.get_pgn(state, player_names=['Player A', 'Player B'])
    self.assertEqual(pgn.headers['White'], 'Player B')
    self.assertEqual(pgn.headers['Black'], 'Player A')

  def test_get_pgn_terminal_state(self):
    spiel_game = pyspiel.load_game('chess')
    spiel_state = spiel_game.new_initial_state()
    # Fool's Mate (https://www.chess.com/terms/fools-mate):
    pgn = """[Event "60th US Open"]
[Site "Omaha, NE USA"]
[Date "1959.08.01"]
[Round "12"]
[White "Walter Thomas Mayfield"]
[Black "William Robert Trinks"]
[Result "1-0"]
[EventDate "?"]
[ECO "B00"]
[WhiteElo "?"]
[BlackElo "?"]
[PlyCount "5"]
[Link "https://www.chess.com/analysis"]

1. e4 g5 2. Nc3 f5 3. Qh5# 1-0"""
    pychess_game = chess.pgn.read_game(io.StringIO(pgn))
    pychess_board = chess.Board()
    for move in pychess_game.mainline_moves():
      spiel_state.apply_action(
          spiel_state.string_to_action(pychess_board.san_and_push(move))
      )
    print(f'{spiel_state=}')
    print(f'{spiel_state.is_terminal()}')
    pgn_from_state = tournament_util.get_pgn(spiel_state)
    self.assertEqual(pgn_from_state.headers['Result'], '1-0')


class TestGetActionStringHistory(absltest.TestCase):

  def test_get_action_string_history_chess_initial_state(self):
    game = pyspiel.load_game('chess')
    state = game.new_initial_state()
    self.assertEqual(tournament_util.get_action_string_history(state), '1.')

  def test_get_action_string_history_chess_with_moves(self):
    game = pyspiel.load_game('chess')
    state = game.new_initial_state()
    state.apply_action(state.string_to_action('e4'))
    state.apply_action(state.string_to_action('e5'))
    self.assertEqual(
        tournament_util.get_action_string_history(state), '1. e4 e5 2.'
    )


class TestGetChessPiecePositions(absltest.TestCase):

  def test_sicilian_defense_position(self):
    """Tests chess piece positions for a common opening position."""
    fen = 'r1bqkbnr/pp1ppppp/2n5/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3'
    expected = {
        'a1': 'white rook',
        'b1': 'white knight',
        'c1': 'white bishop',
        'd1': 'white queen',
        'e1': 'white king',
        'f1': 'white bishop',
        'h1': 'white rook',
        'a2': 'white pawn',
        'b2': 'white pawn',
        'c2': 'white pawn',
        'd2': 'white pawn',
        'f2': 'white pawn',
        'g2': 'white pawn',
        'h2': 'white pawn',
        'f3': 'white knight',
        'e4': 'white pawn',
        'c5': 'black pawn',
        'c6': 'black knight',
        'a7': 'black pawn',
        'b7': 'black pawn',
        'd7': 'black pawn',
        'e7': 'black pawn',
        'f7': 'black pawn',
        'g7': 'black pawn',
        'h7': 'black pawn',
        'a8': 'black rook',
        'c8': 'black bishop',
        'd8': 'black queen',
        'e8': 'black king',
        'f8': 'black bishop',
        'g8': 'black knight',
        'h8': 'black rook',
    }
    result = tournament_util.get_chess_piece_positions(fen)
    self.assertDictEqual(result, expected)

  def test_empty_squares(self):
    """Test the inclusion of empty squares, Kasparov vs. Topalov 1999."""
    fen = '8/Q6p/6p1/5p2/5P2/2p3P1/3r3P/2K1k3 b - - 3 44'
    expected = {
        'a1': 'empty',
        'b1': 'empty',
        'c1': 'white king',
        'd1': 'empty',
        'e1': 'black king',
        'f1': 'empty',
        'g1': 'empty',
        'h1': 'empty',
        'a2': 'empty',
        'b2': 'empty',
        'c2': 'empty',
        'd2': 'black rook',
        'e2': 'empty',
        'f2': 'empty',
        'g2': 'empty',
        'h2': 'white pawn',
        'a3': 'empty',
        'b3': 'empty',
        'c3': 'black pawn',
        'd3': 'empty',
        'e3': 'empty',
        'f3': 'empty',
        'g3': 'white pawn',
        'h3': 'empty',
        'a4': 'empty',
        'b4': 'empty',
        'c4': 'empty',
        'd4': 'empty',
        'e4': 'empty',
        'f4': 'white pawn',
        'g4': 'empty',
        'h4': 'empty',
        'a5': 'empty',
        'b5': 'empty',
        'c5': 'empty',
        'd5': 'empty',
        'e5': 'empty',
        'f5': 'black pawn',
        'g5': 'empty',
        'h5': 'empty',
        'a6': 'empty',
        'b6': 'empty',
        'c6': 'empty',
        'd6': 'empty',
        'e6': 'empty',
        'f6': 'empty',
        'g6': 'black pawn',
        'h6': 'empty',
        'a7': 'white queen',
        'b7': 'empty',
        'c7': 'empty',
        'd7': 'empty',
        'e7': 'empty',
        'f7': 'empty',
        'g7': 'empty',
        'h7': 'black pawn',
        'a8': 'empty',
        'b8': 'empty',
        'c8': 'empty',
        'd8': 'empty',
        'e8': 'empty',
        'f8': 'empty',
        'g8': 'empty',
        'h8': 'empty',
    }
    result = tournament_util.get_chess_piece_positions(
        fen, include_empty_squares=True
    )
    self.assertDictEqual(result, expected)

  def test_empty_board(self):
    """Tests an empty board."""
    fen = '8/8/8/8/8/8/8/8 w - - 0 1'
    expected = {}
    self.assertDictEqual(
        tournament_util.get_chess_piece_positions(fen), expected
    )


class TestGetChessAsciiBoard(absltest.TestCase):

  def test_get_ascii_board_chess(self):
    """Tests ASCII board generation from PySpiel state."""
    pyspiel_game = pyspiel.load_game('chess')
    pyspiel_state = pyspiel_game.new_initial_state(
        'r1bqkb1r/pppp1Qpp/2n2n2/4p3/2B1P3/8/PPPP1PPP/RNB1K1NR b KQkq - 0 4'
    )
    expected_ascii = (
        """r . b q k b . r 8
p p p p . Q p p 7
. . n . . n . . 6
. . . . p . . . 5
. . B . P . . . 4
. . . . . . . . 3
P P P P . P P P 2
R N B . K . N R 1
a b c d e f g h"""
        + '  \n'
        + 'Uppercase letters represent white pieces and lowercase letters'
        ' represent black pieces. The numbers in the right-most column denote'
        ' the ranks and the letters in the bottom row denote the files.'
    )
    self.assertEqual(
        tournament_util.get_ascii_board('chess', pyspiel_state),
        expected_ascii,
    )


if __name__ == '__main__':
  absltest.main()
