# Copyright 2025 The game_arena Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from unittest import mock

from game_arena.harness import agent
from game_arena.harness import model_generation
from game_arena.harness import prompts
from game_arena.harness import rethink
from game_arena.harness import samplers
from game_arena.harness import tournament_util

from absl.testing import absltest
import pyspiel


_SERIALIZED_GAME_AND_STATE_INITIAL = (
    "# Automatically generated by OpenSpiel"
    " SerializeGameAndState\n[Meta]\nVersion:"
    " 1\n\n[Game]\nchess()\n[State]\nFEN:"
    " rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\n\n\n"
)


def _build_chess_agent_with_mock_model(
    prompt_builder: (
        agent.PromptBuilder | None
    ) = agent.default_chess_prompt_builder,
    response_parser: (
        agent.ResponseParser | None
    ) = agent.default_response_parser,
    **kwargs,
) -> agent.ChessLLMAgent:
  mock_model = mock.create_autospec(
      model_generation.Model, instance=True, spec_set=True
  )
  return agent.ChessLLMAgent(
      model=mock_model,
      prompt_builder=prompt_builder,
      response_parser=response_parser,
      **kwargs,
  )


class AgentTest(absltest.TestCase):

  def test_chess_agent_action_submission(self):
    chess_agent = _build_chess_agent_with_mock_model()
    chess_agent.model.generate_with_text_input.return_value = (
        tournament_util.GenerateReturn(
            main_response="Final Answer: e4.",
            main_response_and_thoughts="Thinking... Final Answer: e4.",
        )
    )
    game = pyspiel.load_game("chess")
    state = game.new_initial_state()
    observation = {
        "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
        "legalActions": state.legal_actions(),
    }
    result = chess_agent(observation=observation, configuration={})

    expected_action_int = state.string_to_action("e4")
    self.assertEqual(result["submission"], expected_action_int)
    self.assertEqual(result["actionString"], "e4")
    chess_agent.model.generate_with_text_input.assert_called_once()

  def test_chess_agent_setup_step(self):
    chess_agent = _build_chess_agent_with_mock_model()
    setup_observation = {"serializedGameAndState": None}
    result = chess_agent(observation=setup_observation, configuration={})
    self.assertEqual(
        result,
        {
            "submission": pyspiel.INVALID_ACTION,
            "actionString": None,
            "thoughts": None,
            "status": "Setup step; model not called.",
            "generate_returns": [],
        }
    )
    chess_agent.model.generate_with_text_input.assert_not_called()

  def test_chess_agent_max_model_calls_reached(self):
    chess_agent = _build_chess_agent_with_mock_model(max_model_calls=1, seed=42)
    chess_agent.model.generate_with_text_input.return_value = (
        tournament_util.GenerateReturn(
            main_response="Final Answer: e4.",
            main_response_and_thoughts="Thinking... Final Answer: e4.",
        )
    )
    game = pyspiel.load_game("chess")
    state = game.new_initial_state()
    observation = {
        "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
        "legalActions": state.legal_actions(),
    }
    result1 = chess_agent(observation=observation, configuration={})
    expected_action_int = state.string_to_action("e4")
    self.assertEqual(result1["submission"], expected_action_int)
    self.assertEqual(chess_agent.model.generate_with_text_input.call_count, 1)
    # Second call should not call the model and return a random move.
    result2 = chess_agent(observation=observation, configuration={})
    self.assertIn(result2["submission"], observation["legalActions"])
    self.assertIn("MAX MODEL CALLS", result2["status"])
    # The model should still have been called only once in total.
    chess_agent.model.generate_with_text_input.assert_called_once()

  def test_chess_agent_invalid_move_with_fallback(self):
    chess_agent = _build_chess_agent_with_mock_model(
        fallback_to_random_move=True, seed=42
    )
    chess_agent.model.generate_with_text_input.return_value = (
        tournament_util.GenerateReturn(
            main_response="Final Answer: invalid_move.",
            main_response_and_thoughts="Hmm... Final Answer: invalid_move.",
        )
    )
    game = pyspiel.load_game("chess")
    state = game.new_initial_state()
    observation = {
        "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
        "legalActions": state.legal_actions(),
    }
    result = chess_agent(observation=observation, configuration={})
    self.assertIn(result["submission"], observation["legalActions"])
    chess_agent.model.generate_with_text_input.assert_called_once()

  def test_chess_agent_invalid_move_without_fallback(self):
    chess_agent = _build_chess_agent_with_mock_model(
        fallback_to_random_move=False, seed=42
    )
    chess_agent.model.generate_with_text_input.return_value = (
        tournament_util.GenerateReturn(
            main_response="Final Answer: invalid_move.",
            main_response_and_thoughts="Hmm... Final Answer: invalid_move.",
        )
    )
    game = pyspiel.load_game("chess")
    state = game.new_initial_state()
    observation = {
        "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
        "legalActions": state.legal_actions(),
    }
    result = chess_agent(observation=observation, configuration={})

    self.assertEqual(result["submission"], pyspiel.INVALID_ACTION)
    chess_agent.model.generate_with_text_input.assert_called_once()

  def test_rethink_agent_action_submission(self):
    mock_sampler = mock.create_autospec(rethink.RethinkSampler, instance=True)
    game = pyspiel.load_game("chess")
    state = game.new_initial_state()
    action_str = "e4"
    action_int = state.string_to_action(action_str)

    sampler_output = samplers.SamplerOutput(
        action=action_str,
        extracted_action=action_str,
        matched_action=action_str,
        generate_returns=[
            tournament_util.GenerateReturn(
                main_response="Thinking... Final Answer: e4.",
                main_response_and_thoughts="Thinking... Final Answer: e4.",
            )
        ],
        auxiliary_outputs={},
        move_type=tournament_util.MoveType.LEGAL,
    )
    mock_sampler.sample_action_with_text_and_state_input.return_value = (
        sampler_output
    )

    rethink_agent = agent.ChessRethinkAgent(
        sampler=mock_sampler,
        prompt_template=prompts.PromptTemplate.NO_LEGAL_ACTIONS_RETHINK_APPENDED,
    )

    observation = {
        "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
        "legalActions": state.legal_actions(),
    }
    result = rethink_agent(observation=observation, configuration={})

    self.assertEqual(result["submission"], action_int)
    self.assertEqual(result["actionString"], action_str)
    self.assertEqual(result["thoughts"], "Thinking... Final Answer: e4.")
    self.assertEqual(result["status"], "OK")
    mock_sampler.sample_action_with_text_and_state_input.assert_called_once()

  def test_rethink_agent_setup_step(self):
    mock_sampler = mock.create_autospec(rethink.RethinkSampler, instance=True)
    rethink_agent = agent.ChessRethinkAgent(
        sampler=mock_sampler,
        prompt_template=prompts.PromptTemplate.NO_LEGAL_ACTIONS_RETHINK_APPENDED,
    )
    setup_observation = {"serializedGameAndState": None}
    result = rethink_agent(observation=setup_observation, configuration={})
    self.assertEqual(
        result,
        agent.KaggleSpielActionWithExtras(
            submission=pyspiel.INVALID_ACTION,
            actionString=None,
            thoughts=None,
            status="OK; Setup step; model not called.",
            generate_returns=[],
        ),
    )
    mock_sampler.sample_action_with_text_and_state_input.assert_not_called()

  def test_rethink_agent_max_sampler_calls_reached(self):
    mock_sampler = mock.create_autospec(rethink.RethinkSampler, instance=True)
    game = pyspiel.load_game("chess")
    state = game.new_initial_state()
    action_str = "e4"
    action_int = state.string_to_action(action_str)

    sampler_output = samplers.SamplerOutput(
        action=action_str,
        extracted_action=action_str,
        matched_action=action_str,
        generate_returns=[
            tournament_util.GenerateReturn(
                main_response="some thought",
                main_response_and_thoughts="some thought",
            )
        ],
        auxiliary_outputs={},
        move_type=tournament_util.MoveType.LEGAL,
    )
    mock_sampler.sample_action_with_text_and_state_input.return_value = (
        sampler_output
    )

    rethink_agent = agent.ChessRethinkAgent(
        sampler=mock_sampler,
        prompt_template=prompts.PromptTemplate.NO_LEGAL_ACTIONS_RETHINK_APPENDED,
        max_sampler_calls=1,
        seed=42,
    )

    observation = {
        "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
        "legalActions": state.legal_actions(),
    }
    # First call should call sampler.
    result1 = rethink_agent(observation=observation, configuration={})
    self.assertEqual(result1["submission"], action_int)
    mock_sampler.sample_action_with_text_and_state_input.assert_called_once()

    # Second call should not call the sampler and return a random move.
    result2 = rethink_agent(observation=observation, configuration={})
    self.assertIn(result2["submission"], observation["legalActions"])
    self.assertIn("MAX SAMPLER CALLS", result2["status"])
    # The sampler should still have been called only once in total.
    mock_sampler.sample_action_with_text_and_state_input.assert_called_once()

  def test_rethink_agent_sampler_error(self):
    mock_sampler = mock.create_autospec(rethink.RethinkSampler, instance=True)
    mock_sampler.sample_action_with_text_and_state_input.side_effect = (
        ValueError("Sampler failed")
    )

    rethink_agent = agent.ChessRethinkAgent(
        sampler=mock_sampler,
        prompt_template=prompts.PromptTemplate.NO_LEGAL_ACTIONS_RETHINK_APPENDED,
    )

    game = pyspiel.load_game("chess")
    state = game.new_initial_state()
    observation = {
        "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
        "legalActions": state.legal_actions(),
    }
    result = rethink_agent(observation=observation, configuration={})

    self.assertEqual(result["submission"], agent.ERROR_ACTION_INT)
    self.assertIsNone(result["actionString"])
    self.assertIsNone(result["thoughts"])
    self.assertTrue(result["status"].startswith("ValueError: Sampler failed"))
    mock_sampler.sample_action_with_text_and_state_input.assert_called_once()

  def test_rethink_agent_concat_multiple_thoughts(self):
    mock_sampler = mock.create_autospec(rethink.RethinkSampler, instance=True)
    game = pyspiel.load_game("chess")
    state = game.new_initial_state()
    action_str = "e4"
    action_int = state.string_to_action(action_str)

    sampler_output = samplers.SamplerOutput(
        action=action_str,
        extracted_action=action_str,
        matched_action=action_str,
        generate_returns=[
            tournament_util.GenerateReturn(
                main_response="some thought; Final Answer: e8.",
                main_response_and_thoughts="some thought",
            ),
            tournament_util.GenerateReturn(
                main_response="some thought; Final Answer: e8.",
                main_response_and_thoughts="some thought",
            ),
            tournament_util.GenerateReturn(
                main_response="some thought; Final Answer: e4.",
                main_response_and_thoughts="some thought",
            ),
        ],
        auxiliary_outputs={},
        move_type=tournament_util.MoveType.LEGAL,
    )
    mock_sampler.sample_action_with_text_and_state_input.return_value = (
        sampler_output
    )

    rethink_agent = agent.ChessRethinkAgent(
        sampler=mock_sampler,
        prompt_template=prompts.PromptTemplate.NO_LEGAL_ACTIONS_RETHINK_APPENDED,
    )

    observation = {
        "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
        "legalActions": state.legal_actions(),
    }
    result = rethink_agent(observation=observation, configuration={})

    self.assertEqual(result["submission"], action_int)
    self.assertEqual(result["actionString"], action_str)
    self.assertIn("Rethink Attempt #2", result["thoughts"])
    self.assertEqual(result["status"], "OK")
    mock_sampler.sample_action_with_text_and_state_input.assert_called_once()


if __name__ == "__main__":
  absltest.main()
