# Copyright 2025 The game_arena Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from unittest import mock

import pyspiel
from absl.testing import absltest

from game_arena.harness import (agent, model_generation, prompts, rethink,
                                samplers, tournament_util)

_SERIALIZED_GAME_AND_STATE_INITIAL = (
    "# Automatically generated by OpenSpiel"
    " SerializeGameAndState\n[Meta]\nVersion:"
    " 1\n\n[Game]\nchess()\n[State]\nFEN:"
    " rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\n\n\n"
)


def _build_chess_agent_with_mock_model(
    prompt_builder: agent.PromptBuilder | None = agent.default_chess_prompt_builder,
    response_parser: agent.ResponseParser | None = agent.default_response_parser,
    **kwargs,
) -> agent.ChessLLMAgent:
    mock_model = mock.create_autospec(
        model_generation.Model, instance=True, spec_set=True
    )
    return agent.ChessLLMAgent(
        model=mock_model,
        prompt_builder=prompt_builder,
        response_parser=response_parser,
        **kwargs,
    )


class AgentTest(absltest.TestCase):

    def test_chess_agent_action_submission(self):
        chess_agent = _build_chess_agent_with_mock_model()
        chess_agent.model.generate_with_text_input.return_value = (
            tournament_util.GenerateReturn(
                main_response="Final Answer: e4.",
                main_response_and_thoughts="Thinking... Final Answer: e4.",
            )
        )
        game = pyspiel.load_game("chess")
        state = game.new_initial_state()
        observation = {
            "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
            "legalActions": state.legal_actions(),
        }
        result = chess_agent(observation=observation, configuration={})

        expected_action_int = state.string_to_action("e4")
        self.assertEqual(result["submission"], expected_action_int)
        self.assertEqual(result["actionString"], "e4")
        chess_agent.model.generate_with_text_input.assert_called_once()

    def test_chess_agent_setup_step(self):
        chess_agent = _build_chess_agent_with_mock_model()
        setup_observation = {"serializedGameAndState": None}
        result = chess_agent(observation=setup_observation, configuration={})
        self.assertEqual(
            result,
            {
                "submission": pyspiel.INVALID_ACTION,
                "actionString": None,
                "thoughts": None,
                "status": "Setup step; model not called.",
                "generate_returns": [],
            },
        )
        chess_agent.model.generate_with_text_input.assert_not_called()

    def test_chess_agent_max_model_calls_reached(self):
        chess_agent = _build_chess_agent_with_mock_model(max_model_calls=1, seed=42)
        chess_agent.model.generate_with_text_input.return_value = (
            tournament_util.GenerateReturn(
                main_response="Final Answer: e4.",
                main_response_and_thoughts="Thinking... Final Answer: e4.",
            )
        )
        game = pyspiel.load_game("chess")
        state = game.new_initial_state()
        observation = {
            "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
            "legalActions": state.legal_actions(),
        }
        result1 = chess_agent(observation=observation, configuration={})
        expected_action_int = state.string_to_action("e4")
        self.assertEqual(result1["submission"], expected_action_int)
        self.assertEqual(chess_agent.model.generate_with_text_input.call_count, 1)
        # Second call should not call the model and return a random move.
        result2 = chess_agent(observation=observation, configuration={})
        self.assertIn(result2["submission"], observation["legalActions"])
        self.assertIn("MAX MODEL CALLS", result2["status"])
        # The model should still have been called only once in total.
        chess_agent.model.generate_with_text_input.assert_called_once()

    def test_chess_agent_invalid_move_with_fallback(self):
        chess_agent = _build_chess_agent_with_mock_model(
            fallback_to_random_move=True, seed=42
        )
        chess_agent.model.generate_with_text_input.return_value = (
            tournament_util.GenerateReturn(
                main_response="Final Answer: invalid_move.",
                main_response_and_thoughts="Hmm... Final Answer: invalid_move.",
            )
        )
        game = pyspiel.load_game("chess")
        state = game.new_initial_state()
        observation = {
            "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
            "legalActions": state.legal_actions(),
        }
        result = chess_agent(observation=observation, configuration={})
        self.assertIn(result["submission"], observation["legalActions"])
        chess_agent.model.generate_with_text_input.assert_called_once()

    def test_chess_agent_invalid_move_without_fallback(self):
        chess_agent = _build_chess_agent_with_mock_model(
            fallback_to_random_move=False, seed=42
        )
        chess_agent.model.generate_with_text_input.return_value = (
            tournament_util.GenerateReturn(
                main_response="Final Answer: invalid_move.",
                main_response_and_thoughts="Hmm... Final Answer: invalid_move.",
            )
        )
        game = pyspiel.load_game("chess")
        state = game.new_initial_state()
        observation = {
            "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
            "legalActions": state.legal_actions(),
        }
        result = chess_agent(observation=observation, configuration={})

        self.assertEqual(result["submission"], pyspiel.INVALID_ACTION)
        chess_agent.model.generate_with_text_input.assert_called_once()

    def test_rethink_agent_action_submission(self):
        mock_sampler = mock.create_autospec(rethink.RethinkSampler, instance=True)
        game = pyspiel.load_game("chess")
        state = game.new_initial_state()
        action_str = "e4"
        action_int = state.string_to_action(action_str)

        sampler_output = samplers.SamplerOutput(
            action=action_str,
            extracted_action=action_str,
            matched_action=action_str,
            generate_returns=[
                tournament_util.GenerateReturn(
                    main_response="Thinking... Final Answer: e4.",
                    main_response_and_thoughts="Thinking... Final Answer: e4.",
                )
            ],
            auxiliary_outputs={},
            move_type=tournament_util.MoveType.LEGAL,
        )
        mock_sampler.sample_action_with_text_and_state_input.return_value = (
            sampler_output
        )

        rethink_agent = agent.ChessRethinkAgent(
            sampler=mock_sampler,
            prompt_template=prompts.PromptTemplate.NO_LEGAL_ACTIONS_RETHINK_APPENDED,
        )

        observation = {
            "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
            "legalActions": state.legal_actions(),
        }
        result = rethink_agent(observation=observation, configuration={})

        self.assertEqual(result["submission"], action_int)
        self.assertEqual(result["actionString"], action_str)
        self.assertEqual(result["thoughts"], "Thinking... Final Answer: e4.")
        self.assertEqual(result["status"], "OK")
        mock_sampler.sample_action_with_text_and_state_input.assert_called_once()

    def test_rethink_agent_setup_step(self):
        mock_sampler = mock.create_autospec(rethink.RethinkSampler, instance=True)
        rethink_agent = agent.ChessRethinkAgent(
            sampler=mock_sampler,
            prompt_template=prompts.PromptTemplate.NO_LEGAL_ACTIONS_RETHINK_APPENDED,
        )
        setup_observation = {"serializedGameAndState": None}
        result = rethink_agent(observation=setup_observation, configuration={})
        self.assertEqual(
            result,
            agent.KaggleSpielActionWithExtras(
                submission=pyspiel.INVALID_ACTION,
                actionString=None,
                thoughts=None,
                status="OK; Setup step; model not called.",
                generate_returns=[],
            ),
        )
        mock_sampler.sample_action_with_text_and_state_input.assert_not_called()

    def test_rethink_agent_max_sampler_calls_reached(self):
        mock_sampler = mock.create_autospec(rethink.RethinkSampler, instance=True)
        game = pyspiel.load_game("chess")
        state = game.new_initial_state()
        action_str = "e4"
        action_int = state.string_to_action(action_str)

        sampler_output = samplers.SamplerOutput(
            action=action_str,
            extracted_action=action_str,
            matched_action=action_str,
            generate_returns=[
                tournament_util.GenerateReturn(
                    main_response="some thought",
                    main_response_and_thoughts="some thought",
                )
            ],
            auxiliary_outputs={},
            move_type=tournament_util.MoveType.LEGAL,
        )
        mock_sampler.sample_action_with_text_and_state_input.return_value = (
            sampler_output
        )

        rethink_agent = agent.ChessRethinkAgent(
            sampler=mock_sampler,
            prompt_template=prompts.PromptTemplate.NO_LEGAL_ACTIONS_RETHINK_APPENDED,
            max_sampler_calls=1,
            seed=42,
        )

        observation = {
            "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
            "legalActions": state.legal_actions(),
        }
        # First call should call sampler.
        result1 = rethink_agent(observation=observation, configuration={})
        self.assertEqual(result1["submission"], action_int)
        mock_sampler.sample_action_with_text_and_state_input.assert_called_once()

        # Second call should not call the sampler and return a random move.
        result2 = rethink_agent(observation=observation, configuration={})
        self.assertIn(result2["submission"], observation["legalActions"])
        self.assertIn("MAX SAMPLER CALLS", result2["status"])
        # The sampler should still have been called only once in total.
        mock_sampler.sample_action_with_text_and_state_input.assert_called_once()

    def test_rethink_agent_sampler_error(self):
        mock_sampler = mock.create_autospec(rethink.RethinkSampler, instance=True)
        mock_sampler.sample_action_with_text_and_state_input.side_effect = ValueError(
            "Sampler failed"
        )

        rethink_agent = agent.ChessRethinkAgent(
            sampler=mock_sampler,
            prompt_template=prompts.PromptTemplate.NO_LEGAL_ACTIONS_RETHINK_APPENDED,
        )

        game = pyspiel.load_game("chess")
        state = game.new_initial_state()
        observation = {
            "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
            "legalActions": state.legal_actions(),
        }
        result = rethink_agent(observation=observation, configuration={})

        self.assertEqual(result["submission"], agent.ERROR_ACTION_INT)
        self.assertIsNone(result["actionString"])
        self.assertIsNone(result["thoughts"])
        self.assertTrue(result["status"].startswith("ValueError: Sampler failed"))
        mock_sampler.sample_action_with_text_and_state_input.assert_called_once()

    def test_rethink_agent_concat_multiple_thoughts(self):
        mock_sampler = mock.create_autospec(rethink.RethinkSampler, instance=True)
        game = pyspiel.load_game("chess")
        state = game.new_initial_state()
        action_str = "e4"
        action_int = state.string_to_action(action_str)

        sampler_output = samplers.SamplerOutput(
            action=action_str,
            extracted_action=action_str,
            matched_action=action_str,
            generate_returns=[
                tournament_util.GenerateReturn(
                    main_response="some thought; Final Answer: e8.",
                    main_response_and_thoughts="some thought",
                ),
                tournament_util.GenerateReturn(
                    main_response="some thought; Final Answer: e8.",
                    main_response_and_thoughts="some thought",
                ),
                tournament_util.GenerateReturn(
                    main_response="some thought; Final Answer: e4.",
                    main_response_and_thoughts="some thought",
                ),
            ],
            auxiliary_outputs={},
            move_type=tournament_util.MoveType.LEGAL,
        )
        mock_sampler.sample_action_with_text_and_state_input.return_value = (
            sampler_output
        )

        rethink_agent = agent.ChessRethinkAgent(
            sampler=mock_sampler,
            prompt_template=prompts.PromptTemplate.NO_LEGAL_ACTIONS_RETHINK_APPENDED,
        )

        observation = {
            "serializedGameAndState": _SERIALIZED_GAME_AND_STATE_INITIAL,
            "legalActions": state.legal_actions(),
        }
        result = rethink_agent(observation=observation, configuration={})

        self.assertEqual(result["submission"], action_int)
        self.assertEqual(result["actionString"], action_str)
        self.assertIn("Rethink Attempt #2", result["thoughts"])
        self.assertEqual(result["status"], "OK")
        mock_sampler.sample_action_with_text_and_state_input.assert_called_once()


if __name__ == "__main__":
    absltest.main()
